# このrepositoryの目的
システムコール、open,read,writeを学習することを目的に、catコマンドを模倣した。

# 読み込み
## unistd.h
システムコール
read
write

## fcntl.h
open

# 1.ディスクリプタ関連
おさえておきたいところ↓

このコードではファイルから読み取って、標準出力に書き込むことをしている。

## 間違ったところ
if (write(fd, bf, n) < 0)
のときはtest.txt: Bad file descriptorと表示されるのに
if (write(STDOUT_FILENO, bf, n) < 0)
のときは正しく表示されるのはなぜか？

この違いは、**ファイルディスクリプタのアクセス権限**によるもの。

## 2つのケースの違い

### ケース1: `write(fd, bf, n)` - エラーが発生
```c
fd = open(path, O_RDONLY);  // fd=3, 読み取り専用で開く
write(fd, bf, n);           // fd=3 に書き込もうとする → ❌ エラー
```

### ケース2: `write(STDOUT_FILENO, bf, n)` - 正常動作
```c
fd = open(path, O_RDONLY);      // fd=3, 読み取り専用で開く
write(STDOUT_FILENO, bf, n);    // fd=1 (標準出力) に書き込む → ✅ 正常
```

## なぜエラーが発生するのか

**ファイルディスクリプタには、開く時に指定したアクセス権限が設定されます：**

| ファイルディスクリプタ | 開き方 | 読み取り | 書き込み |
|-------------------|--------|----------|----------|
| fd=3 (test.txt) | `O_RDONLY` | ✅ 可能 | ❌ **不可** |
| fd=1 (標準出力) | 自動設定 | ❌ 不可 | ✅ **可能** |

## 実際の動作

```c
// これは正常に動作
n = read(fd, bf, sizeof(bf));        // fd=3から読み取り ✅
write(STDOUT_FILENO, bf, n);         // fd=1に書き込み ✅

// これはエラーになる
n = read(fd, bf, sizeof(bf));        // fd=3から読み取り ✅  
write(fd, bf, n);                    // fd=3に書き込み ❌ "Bad file descriptor"
```

## エラーメッセージの理由

`write(fd, bf, n)` で fd=3（読み取り専用）に書き込もうとすると：

1. システムが「このファイルディスクリプタは書き込み禁止」と判断
2. **EBADF (Bad file descriptor)** エラーを返す
3. `perror("test.txt")` が「test.txt: Bad file descriptor」と表示

## 正しい cat の動作

```c
read(fd, bf, n);           // ファイルから読み取り
write(STDOUT_FILENO, bf, n); // 標準出力に書き込み（画面表示）
```

つまり、**ファイルから読み取って、画面に表示する**のが `cat` コマンドの正しい動作です。

---

# 2.システムコールと標準ｃ関数の速さ
**混同している概念**を整理する。

## 2つの異なる概念

### 1. システムコール自体の速度（本の内容）
```c
write();  // システムコール - 遅い
printf(); // 標準C関数 - 速い
```

### 2. 画面表示のタイミング（先ほどの説明）
```c
write();  // バッファリングなし → 即座に表示
printf(); // バッファリングあり → 遅延表示
```

## 詳細な比較

### システムコール実行速度
- **`write()`**: カーネル呼び出しが必要 → **実行が遅い**
- **`printf()`**: ユーザー空間で動作 → **実行が速い**

### 画面表示タイミング
- **`write()`**: バッファリングなし → **表示が早い**
- **`printf()`**: バッファリングあり → **表示が遅い**

## 実際の動作時間

````c
// 実行時間の例
printf("hello");     // 0.001ms で実行完了、でも画面表示は後
write(1, "hello", 5); // 0.01ms で実行完了、画面表示も即座
````

## まとめ

- **処理速度**: `printf()` > `write()` （本の通り）
- **表示タイミング**: `write()` > `printf()` （先ほどの説明）

つまり：
- `printf()` は**処理は速いが表示は遅い**
- `write()` は**処理は遅いが表示は速い**

**実行速度と表示タイミングは別の概念**

「実行が速ければ表示も速い」のでは？

**実行完了と画面表示は別のタイミング**

## 具体的な動作の違い

### `printf()` の場合
```c
printf("fdの中身・・・%d\n", fd);
```

**実行フロー:**
1. `printf()` 関数が**0.001ms**で実行完了 ✅ **速い実行**
2. しかし文字列は**内部バッファ**に保存されるだけ
3. 画面への実際の出力は**後で**行われる ⏰ **遅い表示**

### `write()` の場合
```c
write(STDOUT_FILENO, bf, n);
```

**実行フロー:**
1. `write()` システムコールが**0.01ms**で実行完了 ⏰ **遅い実行**
2. 実行と同時に**直接画面に出力される** ✅ **速い表示**

## タイムライン比較

```
時刻    printf()の動作              write()の動作
0ms     関数実行完了 ✅             
1ms     (バッファに保存中...)        システムコール実行完了 ✅
2ms     (まだ表示されない...)        画面に表示される ✅
...
100ms   ようやく画面に表示 ⏰
```

## なぜこうなるのか？

- **`printf()`**: 効率化のため**バッファリング**を使用
  - 実行は速いが、表示は後回し
- **`write()`**: **直接出力**のシステムコール
  - 実行は遅いが、表示は即座

つまり「**実行の速さ ≠ 表示の速さ**」
これがバッファリングの特徴。