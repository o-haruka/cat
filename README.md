# このrepositoryの目的
システムコール、open,read,writeを学習することを目的に、catコマンドを模倣した。

# 読み込み
\#include <unistd.h>→システムコールread、write

\#include <fcntl.h>→open

# 1.ディスクリプタ関連
おさえておきたいところ↓

このコードではファイルから読み取って、標準出力に書き込むことをしている。

## 間違ったところ
if (write(fd, bf, n) < 0)
のときはtest.txt: Bad file descriptorと表示されるのに
if (write(STDOUT_FILENO, bf, n) < 0)
のときは正しく表示されるのはなぜか？

この違いは、**ファイルディスクリプタのアクセス権限**によるもの。

## 2つのケースの違い

### ケース1: `write(fd, bf, n)` - エラーが発生
```c
fd = open(path, O_RDONLY);  // fd=3, 読み取り専用で開く
write(fd, bf, n);           // fd=3 に書き込もうとする → ❌ エラー
```

### ケース2: `write(STDOUT_FILENO, bf, n)` - 正常動作
```c
fd = open(path, O_RDONLY);      // fd=3, 読み取り専用で開く
write(STDOUT_FILENO, bf, n);    // fd=1 (標準出力) に書き込む → ✅ 正常
```

## なぜエラーが発生するのか

**ファイルディスクリプタには、開く時に指定したアクセス権限が設定されます：**

| ファイルディスクリプタ | 開き方 | 読み取り | 書き込み |
|-------------------|--------|----------|----------|
| fd=3 (test.txt) | `O_RDONLY` | ✅ 可能 | ❌ **不可** |
| fd=1 (標準出力) | 自動設定 | ❌ 不可 | ✅ **可能** |

## 実際の動作

```c
// これは正常に動作
n = read(fd, bf, sizeof(bf));        // fd=3から読み取り ✅
write(STDOUT_FILENO, bf, n);         // fd=1に書き込み ✅

// これはエラーになる
n = read(fd, bf, sizeof(bf));        // fd=3から読み取り ✅  
write(fd, bf, n);                    // fd=3に書き込み ❌ "Bad file descriptor"
```

## エラーメッセージの理由

`write(fd, bf, n)` で fd=3（読み取り専用）に書き込もうとすると：

1. システムが「このファイルディスクリプタは書き込み禁止」と判断
2. **EBADF (Bad file descriptor)** エラーを返す
3. `perror("test.txt")` が「test.txt: Bad file descriptor」と表示

## 正しい cat の動作

```c
read(fd, bf, n);           // ファイルから読み取り
write(STDOUT_FILENO, bf, n); // 標準出力に書き込み（画面表示）
```

つまり、**ファイルから読み取って、画面に表示する**のが `cat` コマンドの正しい動作です。

---


# 2.`read()`の戻り値
`read()`システムコールで返される`int n`の値について。

```c
n = read(fd, bf, sizeof(bf));
```

### `n > 0` の場合
- **実際に読み込めたバイト数**
- 正常にデータが読み込めた状態

### `n == 0` の場合
- **EOF（End of File）**
- ファイルの終端に達した
- もう読み込むデータがない

### `n < 0` の場合
- **エラーが発生**
- 何らかの理由で読み込みに失敗した

## あなたのコードでの処理

```c
n = read(fd, bf, sizeof(bf));
if (n < 0)
    die(path);          // エラー処理
if (n == 0)
    break;              // ファイル終端でループ終了
// n > 0 の場合は続行
```

## 具体的なエラー例

`n < 0`になる場合：
- ファイルディスクリプタが無効
- ファイルが削除された
- 権限がない
- ディスクエラー
- など

## まとめ

- **`n > 0`**: 読み込み成功（バイト数）
- **`n == 0`**: ファイル終端（EOF）
- **`n < 0`**: エラー発生

この仕組みにより、ファイルの内容を安全に最後まで読み込むことができる。

---

# 3.`write()`の戻り値
```ssize_t write(int fd, const void *buf, size_t count);```
`write()`システムコールの戻り値について説明します。

```c
ssize_t write(int fd, const void *buf, size_t count);
```

### 戻り値の意味

#### `戻り値 > 0` の場合
- **実際に書き込めたバイト数**
- 正常に書き込みが完了した状態
- 通常は `count` と同じ値が返される

#### `戻り値 == 0` の場合
- **何も書き込めなかった**
- まれなケース（通常は発生しない）

#### `戻り値 < 0` の場合
- **エラーが発生**
- 書き込みに失敗した

## あなたのコードでの処理

```c
if (write(STDOUT_FILENO, bf, n) < 0)
    die(path);          // エラー処理
```

## 具体的な例

```c
char buffer[10] = "hello";
int result;

result = write(STDOUT_FILENO, buffer, 5);
// 正常時: result = 5 (書き込んだバイト数)
// エラー時: result = -1
```

## エラーが発生する場合

`write()` が `-1` を返す場合：
- ファイルディスクリプタが無効
- 書き込み権限がない
- ディスク容量不足
- デバイスエラー
- など

## 完全なエラーチェック例

```c
ssize_t written = write(STDOUT_FILENO, bf, n);
if (written < 0) {
    die(path);                    // エラー処理
} else if (written != n) {
    // 部分的な書き込み（まれなケース）
    fprintf(stderr, "部分的な書き込み\n");
}
```

## まとめ

- **`戻り値 > 0`**: 書き込み成功（バイト数）
- **`戻り値 == 0`**: 何も書き込めず（まれ）
- **`戻り値 < 0`**: エラー発生

---

# 4.システムコールと標準ｃ関数の速さ
**混同している概念**を整理する。

## 2つの異なる概念

### 1. システムコール自体の速度（本の内容）
```c
write();  // システムコール - 遅い
printf(); // 標準C関数 - 速い
```

### 2. 画面表示のタイミング（先ほどの説明）
```c
write();  // バッファリングなし → 即座に表示
printf(); // バッファリングあり → 遅延表示
```

## 詳細な比較

### システムコール実行速度
- **`write()`**: カーネル呼び出しが必要 → **実行が遅い**
- **`printf()`**: ユーザー空間で動作 → **実行が速い**

### 画面表示タイミング
- **`write()`**: バッファリングなし → **表示が早い**
- **`printf()`**: バッファリングあり → **表示が遅い**

## 実際の動作時間

````c
// 実行時間の例
printf("hello");     // 0.001ms で実行完了、でも画面表示は後
write(1, "hello", 5); // 0.01ms で実行完了、画面表示も即座
````

## まとめ

- **処理速度**: `printf()` > `write()` （本の通り）
- **表示タイミング**: `write()` > `printf()` （先ほどの説明）

つまり：
- `printf()` は**処理は速いが表示は遅い**
- `write()` は**処理は遅いが表示は速い**

**実行速度と表示タイミングは別の概念**

「実行が速ければ表示も速い」のでは？

**実行完了と画面表示は別のタイミング**

## 具体的な動作の違い

### `printf()` の場合
```c
printf("fdの中身・・・%d\n", fd);
```

**実行フロー:**
1. `printf()` 関数が**0.001ms**で実行完了 ✅ **速い実行**
2. しかし文字列は**内部バッファ**に保存されるだけ
3. 画面への実際の出力は**後で**行われる ⏰ **遅い表示**

### `write()` の場合
```c
write(STDOUT_FILENO, bf, n);
```

**実行フロー:**
1. `write()` システムコールが**0.01ms**で実行完了 ⏰ **遅い実行**
2. 実行と同時に**直接画面に出力される** ✅ **速い表示**

## タイムライン比較

```
時刻    printf()の動作              write()の動作
0ms     関数実行完了 ✅             
1ms     (バッファに保存中...)        システムコール実行完了 ✅
2ms     (まだ表示されない...)        画面に表示される ✅
...
100ms   ようやく画面に表示 ⏰
```

## なぜこうなるのか？

- **`printf()`**: 効率化のため**バッファリング**を使用
  - 実行は速いが、表示は後回し
- **`write()`**: **直接出力**のシステムコール
  - 実行は遅いが、表示は即座

つまり「**実行の速さ ≠ 表示の速さ**」
これがバッファリングの特徴。